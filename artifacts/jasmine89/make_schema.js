#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

const defaultTabSpace = "  ";
const variableScope = 'static const';
const cKeywords = [
  'auto', 'break', 'case', 'char', 'const', 'continue', 'default',
  'do', 'double', 'else', 'enum', 'extern', 'float', 'for', 'goto',
  'if', 'int', 'long', 'register', 'return', 'short', 'signed',
  'sizeof', 'static', 'struct', 'switch', 'typedef', 'union',
  'unsigned', 'void', 'volatile', 'while'
];

const validJsonValueType = ['null', 'object', 'array', 'string', 'number', 'boolean'];

const valueTypeMacroMapping = {
  'null': 'JASMINE_NODE_NULL',
  'object': 'JASMINE_NODE_OBJECT',
  'array': 'JASMINE_NODE_ARRAY',
  'string': 'JASMINE_NODE_STRING',
  'number': 'JASMINE_NODE_NUMBER',
  'boolean': 'JASMINE_NODE_BOOLEAN'
}

const config = {
  variableCount: 0,
  variableName: ''
}

function isValidCIdentifier(identifier) {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier)) {
    return false;
  }
  return !cKeywords.includes(identifier);
}

function parseArguments() {
  const args = process.argv.slice(2);
  let inputFile = null;
  let outputFile = null;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "-o" && i + 1 < args.length) {
      outputFile = args[i + 1];
      i++;
    } else if (!arg.startsWith("-") && !inputFile) {
      inputFile = arg;
    }
  }

  if (!inputFile) {
    console.error("Error: No input file");
    process.exit(1);
  }

  const ext = path.extname(inputFile);
  const baseName = path.basename(inputFile, ext);

  if (!outputFile) {
    outputFile = baseName + ".h";
  }

  return { inputFile, outputFile };
}

function convertSchema(schema, isNested = false) {
  const topTabSpace = isNested ? defaultTabSpace + defaultTabSpace : ''
  const tabSpace = isNested ? defaultTabSpace + defaultTabSpace + defaultTabSpace : defaultTabSpace
  let propertiesPart = ''
  let declarePart = '';
  const schemaVarName = config.variableName;
  const propVarName = config.variableCount == 0 ? `${config.variableName}Prop` : `${config.variableName}Prop${config.variableCount}`
  config.variableCount++;
  declarePart += `${topTabSpace}{\n`;
  declarePart += `${tabSpace}/* Type       */ ${valueTypeMacroMapping[schema.type]},\n`;
  declarePart += `${tabSpace}/* isOptional */ ${schema.isOptional ? 1 : 0},\n`;
  if (schema.type === 'object') {
    declarePart += `${tabSpace}/* Properties */ ${propVarName}\n`;
  }
  if (schema.type === 'array') {
    declarePart += `${tabSpace}/* Properties */ NULL,\n`;
    declarePart += `${tabSpace}/* Child Type */ ${valueTypeMacroMapping[schema.childType]}\n`;
  }
  declarePart += `${topTabSpace}}`;

  if (schema.type === 'object') {
    propertiesPart += `${variableScope} JasmineObjectPropertySchema ${propVarName}[] = {\n`;
    for (let child of schema.properties) {
      const result = convertSchema(child.schema, true);
      propertiesPart =
        result.propertiesPart +
        propertiesPart +
        `${defaultTabSpace}{\n${defaultTabSpace + defaultTabSpace}"${child.name}",\n` +
        result.declarePart +
        `\n${defaultTabSpace}},\n`;
    }
    propertiesPart += `${defaultTabSpace}/* Terminator */ { NULL }, \n`;
    propertiesPart += `};\n`;
  }

  if (!isNested) {
    declarePart = `${variableScope} JasmineSchema ${schemaVarName} = ` + declarePart + `;\n`
  }

  return { propertiesPart, declarePart };
}

function convertToHeader(jsonData) {
  let headerContent = '/* Generated by make_schema.js */\n';

  const macro = "_" + config.variableName.toUpperCase() + "_"

  headerContent += `#ifndef ${macro}\n`;
  headerContent += `#define ${macro}\n`;
  const { declarePart, propertiesPart } = convertSchema(jsonData.root);
  headerContent += `\n${propertiesPart}\n${declarePart}\n`;
  headerContent += `#endif\n`;

  return headerContent;
}

function validateSchema(propertyName, schema) {
  if (!schema) {
    throw new Error(`Missing schema of '${propertyName}'`);
  }
  if (!validJsonValueType.includes(schema.type)) {
    throw new Error(`Invalid value type '${schema.type}' of '${propertyName}'`)
  }
  const schemaKeys = Object.keys(schema)
  for (let schemaKey of schemaKeys) {
    if (!['type', 'properties', 'isOptional', 'childType'].includes(schemaKey)) {
      throw new Error(`Invalid key '${schemaKey}' in schema of '${propertyName}'`);
    }
  }
  switch(schema.type) {
    case 'array':
      if (!validJsonValueType.includes(schema.type)) {
        throw new Error(`Invalid child type '${schema.type}' of '${propertyName}'`)
      }
      break;
    case 'object':
      if (!Array.isArray(schema.properties)) {
        throw new Error(`Properties of '${propertyName}' should be an array.`)
      }
      for (let child of schema.properties) {
        const propKeys = Object.keys(child)
        for (let propKey of propKeys) {
          if (!['name', 'schema'].includes(propKey)) {
            throw new Error(`Invalid key '${propKey}' in '${propertyName}'.'${child.name}'`);
          }
          if (!child.name) {
            throw new Error(`Properties of '${propertyName}' missing 'name'.`);
          }
        }
        validateSchema(child.name, child.schema)
      }
      break;
    default:
  }
}

function validateSchemaJson(json) {
  if (!json) {
    throw new Error('Failed to load json file.');
  }
  if (!isValidCIdentifier(json.ruleName)) {
    throw new Error(`Rule name '${json.ruleName}' is not a valid c identifier.`);
  }
  validateSchema('root', json.root);
}

function main() {
  const { inputFile, outputFile } = parseArguments();
  try {
    const rawData = fs.readFileSync(inputFile, "utf-8");
    const jsonData = JSON.parse(rawData);
    validateSchemaJson(jsonData);
    config.variableName = jsonData.ruleName
    const headerContent = convertToHeader(jsonData);
    fs.writeFileSync(outputFile, headerContent);
  } catch (error) {
    console.error("Error:");
    console.error(error.message);
    process.exit(1);
  }
}

main();
